
2 -

2.2.
The heart of Vue application is  The Vue Instance.

A Vue instance is always created when you call

new Vue()

In a typical Vue application you will only have one Vue instance.

You will usually tell him to load a component. Doing by passing an option object with a render function which tells to render a app component.

new Vue({ render: h => h(App})


Component hierarchy

The App component is the top level component of this hierarchy.

And it can have a child component.


Router

Router-view
Show the content of the current URL.

The content of the router-view is updated when the URL changes.

2.3.

Install Git

Node Version Manager NVM
https://github.com/creationix/nvm

Install Node with the NVM. See the last version in the following link.
https://nodejs.org/en/
$ nvm install 8.12.3

NVM use this version
$ nvm use 8.11.3

3 -  Creating Vue.js Components and Using Template Syntax.

CLI

Use it if you want to deploy the application to production

$ npm install -g @vue/cli

To install specific version
$ npm install -g @vue/cli@3.0.0-rc.3

Create a project with Vue CLI

$ vue create project-name

Install with
Vue CLI v3.0.0-rc.3
? Please pick a preset: (Use arrow keys)
❯ default (babel, eslint)
  Manually select features


? Check the features needed for your project: (Press <space> to select, <a> to toggle all, <i> to invert selection)
❯◉ Babel
 ◯ TypeScript
 ◯ Progressive Web App (PWA) Support
 ◯ Router
 ◯ Vuex
 ◯ CSS Pre-processors
 ◉ Linter / Formatter
 ◯ Unit Testing
 ◯ E2E Testing


Choose the features wanted.

Each one have an ability to do several things including.

Prompt more information in the command line
Modifing web pack config
Install NPM packages and generating files

This is from the new Vue plugin architecture CLI 3

The idea is to create 0 config environment. The create a lot of config that you do not need to worry about that.

You can choose the feature now or later. If do not have now, a plugin can be created in the future.

Linter used to Conde styling
Execute it whenever a save a file


Vue CLI v3.0.0-rc.3
? Please pick a preset: Manually select features
? Check the features needed for your project: Babel, Linter
? Pick a linter / formatter config: Airbnb
? Pick additional lint features: (Press <space> to select, <a> to toggle all, <i> to invert selection)
❯◉ Lint on save
 ◯ Lint and fix on commit

Vue CLI v3.0.0-rc.3
? Please pick a preset: Manually select features
? Check the features needed for your project: Babel, Linter
? Pick a linter / formatter config: Airbnb
? Pick additional lint features: Lint on save
? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? In dedicated config files
? Save this as a preset for future projects? (y/N)


Install the following plugins if your IDE has them. The following set can be installed in the Visual Studio Code.

ESLint
Vetur
vue


——

$ npm run serve

It will compile the application for development and an start the development server in the port 8080

Vue style guide
Vue style rules said to create components with 2 words name minimum

 I didn't need to hit refresh on this page in order to see my changes. That's because we are using, behind the scenes Vue CLI is using the webpack DevServer, including Hot Module Replacement. So as we make changes to our code, the changes immediately show up in our browser without us having to refresh.


——

-> 3.2

--> Global components

Single-file components (this course will only work with this one)

The easier way to get thing render in Vue is to create a Vue instance.

Like this

new Vue({
    template: '<div>Hello World</div>',
    el: '#app',
});


new Vue -> create a new instance of Vue
template: '<div>Hello World</div>' -> We pass an object option a simple Hello World template.
el: '#app -> Which element on the screen Vue will mount the template in.

And If I want to break things up in smaller usable component?

We can do this with Global Components.


—

And this last line should look a little familiar. This is the options object, and it is the same type of object that we're passing into our Vue instance down here, except that we're just not specifying an element property (el).
Components are just like view instance but without the ‘el’

 To demonstrate this, let's pull this part of the template out into a separate component. So just above this, we'll create a new component, and notice here that we're calling Vue.component, and then we're passing in the name of the component here.

'World' -> it is the component name

const World = Vue.component(
    'World',
    { template: '<span>World</span>' },
);

The World component is assigned to the World variable.
This const variable will make possible to access the component by <World />



This should help underscore the fact that components are really just Vue instances. With just one or two exceptions, the options object that you pass into a new component has the exact same properties available as the one you pass in to a Vue instance. So anyhow, notice that our new World component is assigned to this World variable. So now we can replace this part of our component with that component like this.

From this:

new Vue({
    template: '<div>Hello World</div>',
    el: '#app',
});

to this:

new Vue({
    template: '<div>Hello <World /></div>',
    el: '#app',
});

This World component is a global component. It's just a global constant that I could use anywhere I want.


 This type of component is great for fairly small applications and especially great for prototyping, but it's not a great option for full, single-page applications at larger scale for a few reasons.

First of all, in larger applications, global variables inevitably cause problems because they can be hard to location, but more importantly, it's easy to run into naming conflicts.

Secondly, global components use string templates. That means all of your HTML has to be defined inside a JavaScript string, which means you don't get any syntax highlighting, and you end up doing lots of escaping.

Another limitation of global components is that while they nicely encapsulate your HTML template and component logic, CSS is completely left out of the encapsulation, requiring you to rely on global CSS styling.

And finally, global components have no build-time compilation support, meaning, for example, you can't do any sort of preprocessing with things like Babel. Single-file components help us with all these limitations.


--> Single-file component

A single-file component is a file with a Vue extension.

There are typically three sections in a Vue file, including a template section, a script section, and a style section.

The template and script sections are required, whereas the style section is optional.

1 - the template section is where we define our HTML template.
2 - The script section is where we define the JavaScript functionality of our component and where we export it so that it can be exported elsewhere.
3 - the style section is where we define the CSS classes used by our template.

HomeWorld.vue

# Required - Where we define HTML
<template>
</template>

# Required - Define JS functionality of our component and export to be reused in other places.
<script>
</script>

# Optional - Define css used in this template.
<style>
</style>


Of course, if you look at this file, no browser is going to be able to render a file like this, so Vue files are compiled by webpack at build time to generate HTML, JavaScript, and CSS files that the browser can work with.

This compilation comes for free, already configured for us when we start the project with the CLI. This all makes using single-file components a no-brainer when building full-featured web applications with Vue.

So we'll be using single- file components throughout our course. And you may remember that this is what our App.vue component looks like that was generated by the CLI.

The App.vue component is a single-file component and so is the HelloWorld component that the CLI created that we renamed to our HomePage component.


--> 3.3 - Creating your first component

A new page means a new view component.

Do not put components directly inside the components folder. It will no scale very well when the application becomes larger.

Structure your app by feature areas.

Create a new 'home' folder

--

This make the component able to be exported into other files.

<script>
  export default {
    name: 'RobotBuilder'
  };
</script>

--> 3.4 - Binding Attributes to Data with v-bind

In order to make our new Build page a little more dynamic, we need to start by binding it to data from the component instead of these images being hardcoded in the HTML template.

In order to provide data to our component, we need to update our component options to have a data function.

So down here, we'll add that right here. So this is just going to be a function, and right now we'll just return an empty object.

data() {
  return {}
}


Data file structure

---
parts.js

# So we're using web pack's require.context here to make web pack aware of the image URLs so that we can just use them throughout this JSON data as relative URLs. So down here on line 10, you can see that we're calling images function and passing in a relative URL.
# When this is compiled by web pack, this will point to the relative URL of this image file.
const images = require.context('./images', true, /\.png$/)

# JSON data
const parts = {
  heads: [
    {
      id: 1,
      description: 'A robot head with an unusually large eye and teloscpic neck -- excellent for exploring high spaces.',
      title: 'Large Cyclops',
      src: images('./head-big-eye.png'),
      type: 'heads',
      cost: 1225.5
    },
    {
      id: 2,
      description: 'A friendly robot head with two eyes and a smile -- great for domestic use.',
      title: 'Friendly Bot',
      src: images('./head-friendly.png'),
      cost: 945.0,
      type: 'heads',
      onSale: true
    }
  ]
};

# Export the data
export default parts
---

v-bind -> it is used for apply an expression for the element that it is declared in.

Variables, from the data() function, are available inside the expression.

# we want to bind it to an expression. We can do that like this. So this says bind the source attribute of this image element to this expression in the quotes. And inside that expression, we can access availableParts. So this is the availableParts object that we exposed in our data function.


# Thanks to web pack, and we talked about this just a minute ago, this is the relative URL to the image for this head
v-bind:src="availableParts.heads[0].src"


# So now our data object is an object with an availableParts property that is set to that JSON data.
RobotBuilder.vue
<script>
  import availableParts from '../data/parts';

  export default {
    name: 'RobotBuilder',
    data() {
      return {
        availableParts,
      };
    }
  };
</script>


--> 3.5 - Binding to Events with v-on


In order to react to actions by the user such as clicking on these buttons, we need to bind to the events of those elements.
v-on -> It is used bind events.

v-on:click="functionToBeCalled"

click is the event type



"" -> Here is where the expression are

And that function needs to exist on our component. To do that, we're going to introduce a new property on our component called methods, and that's an object, and then you define each of the functions inside of here that you're going to call from your template.
methods -> it is another section which will be used to store every function used in this template.


  export default {
    name: 'RobotBuilder',
    data() {
      return {
        availableParts,
        selectedHeadIndex: 0,
        selectedLeftArmIndex: 0,
        selectedTorsoIndex: 0,
        selectedRightArmIndex: 0,
        selectedBaseIndex: 0,
      };
    },
    methods: {
      selectNextHead() {
        this.selectedHeadIndex = getNextValidIndex(this.selectedHeadIndex, availableParts.heads.length);
      },
      selectPreviousHead() {
        this.selectedHeadIndex = getPrevieousValidIndex(this.selectedHeadIndex, availableParts.heads.length);
      }
    }
  }


--> 3.6 - Using Shorthand Bindings

Shot version of the binding

v-bind: -> replaced by :
v-on: -> replaced by @

--> 3.7 - Binding to Computed Properties

# Computed properties are like a Decorator for the object. Where we put our render logic there and return only an object to be manipulated inside the template section, which should not have logic on it.

Sometimes you want to be able to easily bind to something in your HTML template that involves a complex calculation.
Doing complex calculations in your HTML template isn't really a great idea.

What would be nice is if we had a selected robot property on our component that we can use.

# All of these expressions are a little ugly. What would be nice is if we had a selected robot property on our component that we can use.
From
<img :src="availableParts.heads[selectedHeadIndex].src" title="head"/>
To
<img :src="selectedRobot.head.src" title="head"/>

like the methods property, this contains methods.

computed: {
  selectedRobot() {
    return {
      head: availableParts.heads[this.selectedHeadIndex],
      leftArm: availableParts.arms[this.selectedLeftArmIndex],
      torso: availableParts.torsos[this.selectedTorsoIndex],
      rightArm: availableParts.arms[this.selectedRightArmIndex],
      base: availableParts.bases[this.selectedBaseIndex]
    }
  }
}

So this is better, and while this one just helps simplify our template a little bit, there are cases where it can simplify them a lot. You really want to be careful not to do too much logic in your templates, and computed properties make that easy.

### Obs
# Inside the expression, you have access to data from the exported section of the current component.
data() attributes
computed functions
method functions

3.8 - Displaying Data with Interpolation


      Our robot builder is looking pretty good, and we've learned how to bind to attributes and events, but we haven't yet learned how to simply just display raw data on the page. We do that with interpolation. To demonstrate that, let's display the name of our robot just above the robot head. If we take a look at the parts data over here, you can see that each part has a title. And the names of the heads actually make for a pretty good name for our robots. So let's display the name of the currently selected head above our robot. Because of our computed property, this is going to be really easy. So let's add a new div right here, and we'll give it a class of robot-name. And let's add that class down here in our styles. And I'm going to position this absolute. And I want to position it about 25 pixels above the top of the head, and then we'll align the text to the center, and then we'll set the width to 100%. Okay, now for the interpolation part. Back up here inside our div, we're just going to add an expression like this.

      So the double brackets is used for interpolation, and inside there, we'll just put an expression. So we just want to use selectedRobot.head.title. And this is it. That's all there is to interpolation, and you can put any valid expression in here. Although, again, it's recommended that you only use simple expressions in your template. Okay, let's go check this out. All right, awesome, you can see here that our robot has a name, and then you can see, as I click through the robot heads, that the robot name up here is changing due to that interpolation expression. So interpolation is really simple. Before we wrap up on interpolation though, let me mention one more performance option. We can add a v-once tag to any element like this, and when you do this, any bindings inside that element will be evaluated once and then never again. This is handy for performance reasons if you have a page with a lot of bindings that are going to render once and then you don't expect the data to change. In our case though, this isn't what we want. If I come over now to our robot builder and cycle through the robot heads, you can see that the binding isn't updated. It updated once when the page was rendered, and then it's not being updated anymore. So we don't want that here, so let's remove it. But it's good to know about for performance reasons. Now that should be updating again. Okay, cool. So next, we're going to take a look at ways to dynamically show and hide our content on our page.

# So the double brackets is used for interpolation, and inside there, we'll just put an expression. So we just want to use selectedRobot.head.title. And this is it. That's all there is to interpolation, and you can put any valid expression in here. Although, again, it's recommended that you only use simple expressions in your template.
{{}}
<div class="robot-name">{{selectedRobot.head.title}}</div>

# Add v-once tag to any element like this, and when you do this, any bindings inside that element will be evaluated once and then never again.
# This is handy for performance reasons if you have a page with a lot of bindings that are going to render once and then you don't expect the data to change.
v-once
<div v-once class="robot-name">{{selectedRobot.head.title}}</div>


#### Performance tips

computed function
v-once

####


3.9 - Conditionally Displaying Content with v-if and v-show

# So the question is, when should we use v-if, and when should we use v-show? Basically, if the content that you are showing and hiding is expensive to generate, and it's going to be shown and hidden frequently, then you should use v-show because Vue won't have to go through the expensive rendering process each time it's redisplayed.

 They expected a boolean for showing or not the element.

v-if ->
Remove the element from the DOM
v-show ->
This on add the style display: none


# if the content that you are showing and hiding is expensive to generate, and it's going to be shown and hidden frequently, then you should use v-show because Vue won't have to go through the expensive rendering process each time it's redisplayed.

# But if your content is not expensive to render like our current example, or if it's not going to be hidden and redisplayed frequently, then v-if is perfect. Right now we're just showing and hiding a span element, but imagine if this was a Vue component that we were showing and hiding, and imagine that that component had a child component which also had child components. You can see how that can get really expensive to rerender. In that case, v-show would be better. In our case, v-if is perfect because it's just a span; it's not expensive to render at all, so we'll leave it with a v-if. Next, let's take a look at how to repeat elements using v-for.
