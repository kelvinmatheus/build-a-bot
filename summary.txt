
2 -

2.2.
The heart of Vue application is  The Vue Instance.

A Vue instance is always created when you call

new Vue()

In a typical Vue application you will only have one Vue instance.

You will usually tell him to load a component. Doing by passing an option object with a render function which tells to render a app component.

new Vue({ render: h => h(App})


Component hierarchy

The App component is the top level component of this hierarchy.

And it can have a child component.


Router

Router-view
Show the content of the current URL.

The content of the router-view is updated when the URL changes.

2.3.

Install Git

Node Version Manager NVM
https://github.com/creationix/nvm

Install Node with the NVM. See the last version in the following link.
https://nodejs.org/en/
$ nvm install 8.12.3

NVM use this version
$ nvm use 8.11.3

3 -  Creating Vue.js Components and Using Template Syntax.

CLI

Use it if you want to deploy the application to production

$ npm install -g @vue/cli

To install specific version
$ npm install -g @vue/cli@3.0.0-rc.3

Create a project with Vue CLI

$ vue create project-name

Install with
Vue CLI v3.0.0-rc.3
? Please pick a preset: (Use arrow keys)
❯ default (babel, eslint)
  Manually select features


? Check the features needed for your project: (Press <space> to select, <a> to toggle all, <i> to invert selection)
❯◉ Babel
 ◯ TypeScript
 ◯ Progressive Web App (PWA) Support
 ◯ Router
 ◯ Vuex
 ◯ CSS Pre-processors
 ◉ Linter / Formatter
 ◯ Unit Testing
 ◯ E2E Testing


Choose the features wanted.

Each one have an ability to do several things including.

Prompt more information in the command line
Modifing web pack config
Install NPM packages and generating files

This is from the new Vue plugin architecture CLI 3

The idea is to create 0 config environment. The create a lot of config that you do not need to worry about that.

You can choose the feature now or later. If do not have now, a plugin can be created in the future.

Linter used to Conde styling
Execute it whenever a save a file


Vue CLI v3.0.0-rc.3
? Please pick a preset: Manually select features
? Check the features needed for your project: Babel, Linter
? Pick a linter / formatter config: Airbnb
? Pick additional lint features: (Press <space> to select, <a> to toggle all, <i> to invert selection)
❯◉ Lint on save
 ◯ Lint and fix on commit

Vue CLI v3.0.0-rc.3
? Please pick a preset: Manually select features
? Check the features needed for your project: Babel, Linter
? Pick a linter / formatter config: Airbnb
? Pick additional lint features: Lint on save
? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? In dedicated config files
? Save this as a preset for future projects? (y/N)


Install the following plugins if your IDE has them. The following set can be installed in the Visual Studio Code.

ESLint
Vetur
vue


——

$ npm run serve

It will compile the application for development and an start the development server in the port 8080

Vue style guide
Vue style rules said to create components with 2 words name minimum

 I didn't need to hit refresh on this page in order to see my changes. That's because we are using, behind the scenes Vue CLI is using the webpack DevServer, including Hot Module Replacement. So as we make changes to our code, the changes immediately show up in our browser without us having to refresh.


——

-> 3.2

--> Global components

Single-file components (this course will only work with this one)

The easier way to get thing render in Vue is to create a Vue instance.

Like this

new Vue({
    template: '<div>Hello World</div>',
    el: '#app',
});


new Vue -> create a new instance of Vue
template: '<div>Hello World</div>' -> We pass an object option a simple Hello World template.
el: '#app -> Which element on the screen Vue will mount the template in.

And If I want to break things up in smaller usable component?

We can do this with Global Components.


—

And this last line should look a little familiar. This is the options object, and it is the same type of object that we're passing into our Vue instance down here, except that we're just not specifying an element property (el).
Components are just like view instance but without the ‘el’

 To demonstrate this, let's pull this part of the template out into a separate component. So just above this, we'll create a new component, and notice here that we're calling Vue.component, and then we're passing in the name of the component here.

'World' -> it is the component name

const World = Vue.component(
    'World',
    { template: '<span>World</span>' },
);

The World component is assigned to the World variable.
This const variable will make possible to access the component by <World />



This should help underscore the fact that components are really just Vue instances. With just one or two exceptions, the options object that you pass into a new component has the exact same properties available as the one you pass in to a Vue instance. So anyhow, notice that our new World component is assigned to this World variable. So now we can replace this part of our component with that component like this.

From this:

new Vue({
    template: '<div>Hello World</div>',
    el: '#app',
});

to this:

new Vue({
    template: '<div>Hello <World /></div>',
    el: '#app',
});

This World component is a global component. It's just a global constant that I could use anywhere I want.


 This type of component is great for fairly small applications and especially great for prototyping, but it's not a great option for full, single-page applications at larger scale for a few reasons.

First of all, in larger applications, global variables inevitably cause problems because they can be hard to location, but more importantly, it's easy to run into naming conflicts.

Secondly, global components use string templates. That means all of your HTML has to be defined inside a JavaScript string, which means you don't get any syntax highlighting, and you end up doing lots of escaping.

Another limitation of global components is that while they nicely encapsulate your HTML template and component logic, CSS is completely left out of the encapsulation, requiring you to rely on global CSS styling.

And finally, global components have no build-time compilation support, meaning, for example, you can't do any sort of preprocessing with things like Babel. Single-file components help us with all these limitations.


--> Single-file component

A single-file component is a file with a Vue extension.

There are typically three sections in a Vue file, including a template section, a script section, and a style section.

The template and script sections are required, whereas the style section is optional.

1 - the template section is where we define our HTML template.
2 - The script section is where we define the JavaScript functionality of our component and where we export it so that it can be exported elsewhere.
3 - the style section is where we define the CSS classes used by our template.

HomeWorld.vue

# Required - Where we define HTML
<template>
</template>

# Required - Define JS functionality of our component and export to be reused in other places.
<script>
</script>

# Optional - Define css used in this template.
<style>
</style>


Of course, if you look at this file, no browser is going to be able to render a file like this, so Vue files are compiled by webpack at build time to generate HTML, JavaScript, and CSS files that the browser can work with.

This compilation comes for free, already configured for us when we start the project with the CLI. This all makes using single-file components a no-brainer when building full-featured web applications with Vue.

So we'll be using single- file components throughout our course. And you may remember that this is what our App.vue component looks like that was generated by the CLI.

The App.vue component is a single-file component and so is the HelloWorld component that the CLI created that we renamed to our HomePage component.


--> 3.3 - Creating your first component

A new page means a new view component.

Do not put components directly inside the components folder. It will no scale very well when the application becomes larger.

Structure your app by feature areas.

Create a new 'home' folder

--

This make the component able to be exported into other files.

<script>
  export default {
    name: 'RobotBuilder'
  };
</script>

--> 3.4 - Binding Attributes to Data with v-bind

In order to make our new Build page a little more dynamic, we need to start by binding it to data from the component instead of these images being hardcoded in the HTML template.

In order to provide data to our component, we need to update our component options to have a data function.

So down here, we'll add that right here. So this is just going to be a function, and right now we'll just return an empty object.

data() {
  return {}
}


Data file structure

---
parts.js

# So we're using web pack's require.context here to make web pack aware of the image URLs so that we can just use them throughout this JSON data as relative URLs. So down here on line 10, you can see that we're calling images function and passing in a relative URL.
# When this is compiled by web pack, this will point to the relative URL of this image file.
const images = require.context('./images', true, /\.png$/)

# JSON data
const parts = {
  heads: [
    {
      id: 1,
      description: 'A robot head with an unusually large eye and teloscpic neck -- excellent for exploring high spaces.',
      title: 'Large Cyclops',
      src: images('./head-big-eye.png'),
      type: 'heads',
      cost: 1225.5
    },
    {
      id: 2,
      description: 'A friendly robot head with two eyes and a smile -- great for domestic use.',
      title: 'Friendly Bot',
      src: images('./head-friendly.png'),
      cost: 945.0,
      type: 'heads',
      onSale: true
    }
  ]
};

# Export the data
export default parts
---

v-bind -> it is used for apply an expression for the element that it is declared in.

Variables, from the data() function, are available inside the expression.

# we want to bind it to an expression. We can do that like this. So this says bind the source attribute of this image element to this expression in the quotes. And inside that expression, we can access availableParts. So this is the availableParts object that we exposed in our data function.


# Thanks to web pack, and we talked about this just a minute ago, this is the relative URL to the image for this head
v-bind:src="availableParts.heads[0].src"


# So now our data object is an object with an availableParts property that is set to that JSON data.
RobotBuilder.vue
<script>
  import availableParts from '../data/parts';

  export default {
    name: 'RobotBuilder',
    data() {
      return {
        availableParts,
      };
    }
  };
</script>


--> 3.5 - Binding to Events with v-on


In order to react to actions by the user such as clicking on these buttons, we need to bind to the events of those elements.
v-on -> It is used bind events.

v-on:click="functionToBeCalled"

click is the event type



"" -> Here is where the expression are

And that function needs to exist on our component. To do that, we're going to introduce a new property on our component called methods, and that's an object, and then you define each of the functions inside of here that you're going to call from your template.
methods -> it is another section which will be used to store every function used in this template.


  export default {
    name: 'RobotBuilder',
    data() {
      return {
        availableParts,
        selectedHeadIndex: 0,
        selectedLeftArmIndex: 0,
        selectedTorsoIndex: 0,
        selectedRightArmIndex: 0,
        selectedBaseIndex: 0,
      };
    },
    methods: {
      selectNextHead() {
        this.selectedHeadIndex = getNextValidIndex(this.selectedHeadIndex, availableParts.heads.length);
      },
      selectPreviousHead() {
        this.selectedHeadIndex = getPrevieousValidIndex(this.selectedHeadIndex, availableParts.heads.length);
      }
    }
  }


--> 3.6 - Using Shorthand Bindings

Shot version of the binding

v-bind: -> replaced by :
v-on: -> replaced by @

--> 3.7 - Binding to Computed Properties

# Computed properties are like a Decorator for the object. Where we put our render logic there and return only an object to be manipulated inside the template section, which should not have logic on it.

Sometimes you want to be able to easily bind to something in your HTML template that involves a complex calculation.
Doing complex calculations in your HTML template isn't really a great idea.

What would be nice is if we had a selected robot property on our component that we can use.

# All of these expressions are a little ugly. What would be nice is if we had a selected robot property on our component that we can use.
From
<img :src="availableParts.heads[selectedHeadIndex].src" title="head"/>
To
<img :src="selectedRobot.head.src" title="head"/>

like the methods property, this contains methods.

computed: {
  selectedRobot() {
    return {
      head: availableParts.heads[this.selectedHeadIndex],
      leftArm: availableParts.arms[this.selectedLeftArmIndex],
      torso: availableParts.torsos[this.selectedTorsoIndex],
      rightArm: availableParts.arms[this.selectedRightArmIndex],
      base: availableParts.bases[this.selectedBaseIndex]
    }
  }
}

So this is better, and while this one just helps simplify our template a little bit, there are cases where it can simplify them a lot. You really want to be careful not to do too much logic in your templates, and computed properties make that easy.

### Obs
# Inside the expression, you have access to data from the exported section of the current component.
data() attributes
computed functions
method functions

3.8 - Displaying Data with Interpolation


      Our robot builder is looking pretty good, and we've learned how to bind to attributes and events, but we haven't yet learned how to simply just display raw data on the page. We do that with interpolation. To demonstrate that, let's display the name of our robot just above the robot head. If we take a look at the parts data over here, you can see that each part has a title. And the names of the heads actually make for a pretty good name for our robots. So let's display the name of the currently selected head above our robot. Because of our computed property, this is going to be really easy. So let's add a new div right here, and we'll give it a class of robot-name. And let's add that class down here in our styles. And I'm going to position this absolute. And I want to position it about 25 pixels above the top of the head, and then we'll align the text to the center, and then we'll set the width to 100%. Okay, now for the interpolation part. Back up here inside our div, we're just going to add an expression like this.

      So the double brackets is used for interpolation, and inside there, we'll just put an expression. So we just want to use selectedRobot.head.title. And this is it. That's all there is to interpolation, and you can put any valid expression in here. Although, again, it's recommended that you only use simple expressions in your template. Okay, let's go check this out. All right, awesome, you can see here that our robot has a name, and then you can see, as I click through the robot heads, that the robot name up here is changing due to that interpolation expression. So interpolation is really simple. Before we wrap up on interpolation though, let me mention one more performance option. We can add a v-once tag to any element like this, and when you do this, any bindings inside that element will be evaluated once and then never again. This is handy for performance reasons if you have a page with a lot of bindings that are going to render once and then you don't expect the data to change. In our case though, this isn't what we want. If I come over now to our robot builder and cycle through the robot heads, you can see that the binding isn't updated. It updated once when the page was rendered, and then it's not being updated anymore. So we don't want that here, so let's remove it. But it's good to know about for performance reasons. Now that should be updating again. Okay, cool. So next, we're going to take a look at ways to dynamically show and hide our content on our page.

# So the double brackets is used for interpolation, and inside there, we'll just put an expression. So we just want to use selectedRobot.head.title. And this is it. That's all there is to interpolation, and you can put any valid expression in here. Although, again, it's recommended that you only use simple expressions in your template.
{{}}
<div class="robot-name">{{selectedRobot.head.title}}</div>

# Add v-once tag to any element like this, and when you do this, any bindings inside that element will be evaluated once and then never again.
# This is handy for performance reasons if you have a page with a lot of bindings that are going to render once and then you don't expect the data to change.
v-once
<div v-once class="robot-name">{{selectedRobot.head.title}}</div>


#### Performance tips

computed function
v-once

####


3.9 - Conditionally Displaying Content with v-if and v-show

# So the question is, when should we use v-if, and when should we use v-show? Basically, if the content that you are showing and hiding is expensive to generate, and it's going to be shown and hidden frequently, then you should use v-show because Vue won't have to go through the expensive rendering process each time it's redisplayed.

 They expected a boolean for showing or not the element.

v-if ->
Remove the element from the DOM
v-show ->
This on add the style display: none


# if the content that you are showing and hiding is expensive to generate, and it's going to be shown and hidden frequently, then you should use v-show because Vue won't have to go through the expensive rendering process each time it's redisplayed.

# But if your content is not expensive to render like our current example, or if it's not going to be hidden and redisplayed frequently, then v-if is perfect. Right now we're just showing and hiding a span element, but imagine if this was a Vue component that we were showing and hiding, and imagine that that component had a child component which also had child components. You can see how that can get really expensive to rerender. In that case, v-show would be better. In our case, v-if is perfect because it's just a span; it's not expensive to render at all, so we'll leave it with a v-if. Next, let's take a look at how to repeat elements using v-for.


3.10 - Repeating Elements with v-for

### Atention

let's add a cart property, and we'll default it to an empty array. And it's important that we initialize this variable here in the data function. If we don't do it here, Vue won't notice that the data is changing. Vue's change detection works by hooking into the getters and setters of properties in the data function. And so even if we were to add a cart variable below by saying this.cart=newArray, Vue wouldn't even notice it because it never hooked into it.


# So we'll say this.cart.push, and then just for immutability purposes, I want to use Object.assign here so that the robot that is in the array isn't the same instance as the selected robot property. This isn't really a Vue thing; this is more of a good programming practice in JavaScript to make sure that you don't have inadvertent pointers to the same object in your code.

// 1 - Start with an empty object {}
// 2 - assign robot
// 3 - Content of the robot
// the result we will have a copy of the robot object with the cost add to it. Them we push it into the cart.
this.cart.push(Object.assign({}, robot, { cost }));

cart is the attribute that has the data
robot is the element from the array
index is the index of the array

v-bind:key or :key or key="" is used to add a key to the element repeated. It is a requirement of Vue.

:key="index" -> will get the index from the for expression
key="index" -> here, index is only a string.

<tr v-for="(robot, index) in cart" :key="index">
  <td>{{robot.head.title}}</td>
  <td class="cost">{{robot.cost}}</td>
</tr>

# Without the key attribute
<tr v-for="robot in cart">

# There's just one caveat here. Whenever you're repeating data, Vue needs to be able to, for performance reasons, identify each element in there for updates. And so we need to add a unique key attribute to our repeated table row element.

### Obs

# This is just a performance warning that you'll see in the Vue docs
For performance, you should not use v-if and v-for in the same element

3.11 - Styling Components

# So this index.html file is what is actually loaded when our app first loads
index.html

# So we just essentially scoped all of the styles inside this style element to only this App (to the specific component) component.
<style scoped>
</style>

This
<header data-v-7ba5bd90>
 ...
</header>

# It will only apply this header to the one that has this data-v attribute data-v-7ba5bd90
header[data-v-7ba5bd90] {
    background-color: #999;
    width: 1084px;
    margin: 0 auto;
}


# So that's how Vue handles scoping styles. It puts these randomized hashes on scoped elements and then targets them specifically with that hash. So a header element on another component would either not have this data attribute at all, or it would have a different data attribute because it's in a different scope. And the same concept applies to child components, as we'll see in the next clip. With some exceptions, if you add the scoped element to a parent component, its styles won't bleed into the child component.


# So about scoped versus global styles.

The App.vue file is the best file to have a Global style
<style>

</style>

<style scoped>
</style>


3.12 - Styling Child Components

# If you want to be able to do deep targeting like this, you need to use the deep selector that looks like this. And now if we take a look at it, there, now you can see that we can target it. So you can target child elements within scoped styles like this by starting with the class of the root element and then using the deep selector to select other items within the child component. But you need to be aware that this deep component is truly deep. It is not just the child component, but this will also affect child components of your child component, so it will keep going down the chain. And it's possible that this won't work with some CSS preprocessors, and so in that case, there is also the deep selector, and that has the same effect. Okay, we don't want to keep this here, so let's delete that. That covers everything for styling child components. Next, let's take a look at conditionally applying styles to elements.

How to style child components from a scoped parent style.

Start with the class of the root element and them add  deep selector (>>>) + the class that you want to edit.

# parent scoped style

>>> -> Deep selector -> Obs> it cannot work in some preprocessor so, use the /deep/ selector instead. It has the same meaning.
.content >>> .robot-name {
  ...
}

# child
<template>
  <div class="content">
    <div class="top-row">
      <div class="top part">
        <div class="robot-name">
        </div>
      </div>
    </div>
  </div
</template>

3.13 - Conditionally Applying Styles with Style Bindings

Sometimes we want to apply a style to an element based upon a certain condition. That's quite easy to do with Vue. Let's use a style binding to make it so that the border around the head turns red if it's on sale. So over here in our template, we're going to style this div right here. It's the one that contains the head. So a style binding looks like this. And really, this is just binding to the style attribute. And you provide an object, and we're going to set the border to a 3px solid red border. And this should be working, if we go over here and take a look at it. However, it's not yet conditional. So every head has a red border, not just the ones that are on sale. So we'll get to conditional in just a second, but first I want to mention that there are some CSS attributes that have hyphens in them. For example, background-color. But this isn't valid JavaScript. For this to be valid JavaScript, you have to add brackets around this because this is object notation here. But Vue actually makes this easier by allowing you to use camel case for CSS attribute names that have hyphens in them, so just keep that in mind. We don't need this though, so we'll just change this back to border. So for this to be conditional, we need to not just have it be hardcoded to a string, so we can just change that to bind to a computer property on the component. So instead of this object here, we're just going to bind this to headBorderStyle. Now the style binding will be set to whatever object is returned by headBorderStyle. So let's go add a computed property for that. So that's a method, and it's just going to, for now we'll have it just return border, and we'll hardcode that again to 3px solid red. Okay, so this still isn't dynamic. We still are just getting a red border on everything. But now, because this is a computed property, we could just use a ternary here. So let's bring this down onto a separate line, and instead of always setting border to this string, we'll set it to a ternary statement. We'll say if this.selectedRobot.head is onSale, then return 3px solid red. Otherwise, return 3px solid gray. Okay, let's go check that out. Okay, it looks like this is working great now. So now only the items that's on sale has a red border. Okay, one last thing to be aware of is up here in our style binding, sometimes it's necessary to apply styles based on multiple calculations. In that case, we could add an array, or bind this to an array instead. And this could be a second calculated property so that it applies these styles, the headBorderStyle first, and then moreStyles second. And moreStyles will override headBorderStyle, so the second one overrides the first if there are any conflicts. We don't have a need for that, though, so we'll just go with the simple object syntax. Of course, it's better to use classes than inline styles, so now let's take a look at how to conditionally apply CSS classes.

Bind style
:style="{ border: '3px solid red'; }"
:style="{ [background-color]: red }"
:style="{ backgroundColor: red }" ->  Vue syntax with camelcase

It is needed to add square brackets when use css attributes has hyphen because it is object notation.

Vue makes it easier by allowing camelcase syntax


:style="[headBorderStyle, otherComputedStyle]"


 :class="{ 'sale-border': selectedRobot.head.onSale }"

 But it is better to put this logic inside the computed property

# saleBorderClass -> it returns a string class
<div class="top part" :class="[saleBorderClass]">


3.14 - Conditionally Applying Classes with Class Bindings
Let's see how to replace this style binding with a class binding so that we can use classes instead of inline styles. First, let's start by adding a class down here. We'll call it sale-border, and that will just have a border that is 3px solid red. And then back up here where our style binding is, instead of this we'll use a class binding. And then a class binding is basically an object where the keys are the names of the classes that you would like to toggle. So in this case, we have a sale-border class. And then you just set that to a Boolean expression that will evaluate to true when you want this class to be applied. So in this case we want it to be applied when the selectedRobot.head is onSale. So this is just saying apply the sale-border class when the onSale property is true. And if we wanted to toggle multiple classes, we would just add more properties to this object. So this should be working just like the style binding was. So the Friendly Bot is on sale, and the rest are not on sale. Perfect. Now one thing that you might not have noticed, if we inspect this, this div where we applied the sale border, also has the classes top and part. If we go over and take a look at our template, you can see that this element has both a class binding and a class attribute on it, so the top and part classes are going to always be applied, and the sale-border property is going to be applied conditionally, so you can combine them like this. Of course, this class object could get fairly complex if you were toggling lots of classes. So you could always move this expression to a computed property like we did with the style binding. But like style bindings, there's another syntax that we could use here, an array syntax. So I could just provide an array here, and that array contains the classes that I would like to apply. So this is not conditional; this will always apply a class, so we should be seeing that everywhere. But we could then take this and, let's undo a little bit and grab this expression, and with this array syntax, let's put in a, let's use a computed property like we did with our style bindings. So I'm going to create a computed property called saleBorderClass, and we will add the value of that to our array. So now down in our computed properties, I can change this to saleBorderClass. And then this is just going to return the saleBorder string if the robot head is on sale, so we'll just use a ternary like this. So if it's on sale, then return sale-border. Otherwise it'll return an empty string. And we need this here. Okay, so that should be conditional again. There we go. And now that we have that using the array syntax, we could actually collapse these class expressions into a single expression. So I'm going to take these out of here and make them strings in here. And then I can get rid of this class attribute, and now it's all taken care of in our class binding. Cool, I like that final syntax, so let's go with that. And next, we'll take a look at using CSS preprocessors like Sass.


3.15 - Using SASS and Other CSS Pre-processors
Vue.js fully supports using CSS preprocessors if, for example, you want to use something like Sass instead of plain old CSS. In fact, the zero-config web pack configuration that comes with the basic CLI includes all of the web pack config to support Sass, Less, and Stylus. All you have to do is npm install the appropriate loaders if you want to use them. So here in our terminal, I'm going to just npm install node-sass and sass-loader and save that. Let's go ahead and install that. And since the built-in web pack config is already set up to handle the Sass loader, we can just jump in using that in our project. So all we have to do to support Sass is come down to the Style section, and up here at the top where we define our style tag, all we need to do is specify the language used here, so I can say lang=scss. And now I can start using Sass syntax in here, so I could, for example, wrap this inside of the part class, and then if we come back over here and start our server again and then come back over to our browser and refresh, you can see that all our styles, so these images, are still the correct size, even though we added the Sass syntax for sizing them. So that was surprisingly easy, and you can see how the zero-config environment made that really simple. Of course, if you wanted to use a CSS preprocessor other than Sass, Less, or Stylus, you could do that, but you would have to go in and modify the web pack config, and we'll talk about that in the deploying to production module. But out of the box, those three are already supported. And now our robot builder is using Sass. This wraps up our discussion of styling our components. We're going to next take a look at the different component lifecyle hooks that we can tap into.


$ npm install node-sass sass-loader --save-dev


And since the built-in web pack config is already set up to handle the Sass loader, we can just jump in using that in our project.

Now just need to add the language scss the the style tag which you want to use the SCSS preprocessor.

<style lang="scss" scoped>


3.16 - Using Component Lifecycle Hooks
       There are several lifecycle hooks that we can tap into to take an action based on the various lifecycle states of a component. Let's take a look at the created lifecycle hook. A typical use case for lifecycle hooks is to fetch data from a API when a component is first created, but we're not ready to do that just yet. We'll implement that exact use case later in the module about state management when we start using an API. For now, let's just make it so that whenever this RobotBuilder component is created, we log something into the console. So all we need to do is add a created function like this. And then we can just console.log in here. And tapping into a lifecyle hook is that easy. Let's go check this out over in our browser. So let's open our console and clear it, and then I'm going to refresh this. And when this page loaded, the RobotBuilder component was created. And then you can see down here we got this component created message. And again, this isn't a great use case, obviously, but it's pretty common that you'll do things in here like fetch data from an API that's needed for this component. There are a handful of lifecycle hooks, but covering all of them is beyond the scope of this course. If you want to explore more about lifecyle hooks, you can check it out here in the Vue documentation. They provide this lifecyle diagram that shows all of the different lifecycle hooks, beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, and beforeDestroy, and finally, destroyed. And it shows you in this diagram here where in the lifecycle of a component each of these hooks gets called. And again, we'll touch on this more later in the course. If you want to look at it right now, to explore lifecycle states further, you can check it out in the Passing Data to Parent Components clip, which is inside the Enabling Intercomponent Communication module, or you can also look at it in the State Management module when we start talking about making API calls. For now, let's move on and take a look at mixins.


lifecycle hooks

There are several lifecycle hooks that we can tap into to take an action based on the various lifecycle states of a component. Let's take a look at the created lifecycle hook.
A typical use case for lifecycle hooks is to fetch data from a API when a component is first created.

To use the created lifecycle hook just add it to the export default object:

created() {
}


3.17 - Reducing Duplication with Mixins
        Let's see how to do that. Let's take this created lifecycle hook and move it into a mixin. So we'll grab it from here, and then let's create a new file called created-hook-mixin.js. And then here we'll just export an object. So basically, we're just export a component configuration object here, and whatever is in this object will be merged in with any components that you use it in. So to use it, let's go back into our RobotBuilder, and we're going to import our createdHookMixin from created-hook-mixin. And then we're just going to use this down here in a mixin property, so mixins, and then this is just an array of mixins, and we're only going to have one, the createdHookMixin. Cool. Now this mixin can be used in multiple components. Right now, we're just going to be using it in this one. And if we come back over to our web app and open our console and refresh, you can see our component created messages still getting logged. And so our created hook is still working, but it is now extracted out into a mixin that could be reused. Again, our application isn't quite mature enough yet for a great example for mixins. If you want to see a better example of this, in the Managing State with Vuex module, we talk about it when we have a few components that all need the same data, so we'll create a mixin in order to share the logic that will be used to fetch that data across multiple components. You can find that in the clip on Using Actions to Work with APIs and Asynchronous Data. I just wanted to talk about it a little bit here in the components section so that you knew about it. And just be aware, you can use a mixin to share any component option across multiple components including lifecycle hooks, props, computed properties, etc.


Mixins are a way to share functionality across multiple components. Basically, any component option can be extracted out into a mixin file, and then when you import the mixin, it will be merged into the rest of your component options.


It will be merged in to any component that use it.


You can use a mixin to share any component option across multiple components including lifecycle hooks, props, computed properties, etc.


3.18 - Summary

Creating Components
Using Bindings to Display Data and Handle Events
Conditionally Displaying Elements with v-if and v-show
Repeating ELements with v-for
Styling Components
Working with Compoment Lifecycle Hooks
Reducing Duplication with Mixins

-------------------------------------------------------------

-> 4 - Enabling Inter-component Communication

--> 4.1 - Introduction

Using Props to Share Data with Child Components
Validating Component Props
Passing Data to Parent Components with Events
Injecting Conent into a Child Componet with Slots
￼
--> 4.2 - Creating Child Components
So far, we haven't really done much with creating child components, other than the fact that our App component uses our RobotBuilder component. If we take a look at this RobotBuilder template, you can see a lot of repeating code here for each of the individual part selectors. Let's turn this into a part selector component and reuse it in each of these places. When we do that, we'll need to pass down to the PartSelector component the parts that we want it to select from, and that will be a great way to show how to communicate between components. So we'll start by creating a PartSelector component, and rather than completing this whole thing from scratch, let's start with a partially completed component. So over here in our helper repo in the src, build folder, we have this PartSelector.vue file. So let's grab that and paste that into our new component. So if we take a look at what we've pasted in here, you can see that at the top here we have some HTML that looks a lot like the HTML that was being repeated multiple times over in our RobotBuilder. And then down here in the component script, you can see that we have some functions for getting the next and previous index, and down here methods on our component for selecting the next part and the previous part that call those functions. This should look a little bit familiar because this same code, or code a lot like it, existed over in our RobotBuilder. So we've just moved that over into our PartSelector. And then notice up here, we're importing all of the available parts, and we're setting, here on line 13, this parts variable to the heads from the availableParts. This is just temporary so we can get up and going. The parts for the PartSelector will actually be passed into us by its parent component, so we'll delete this pretty quick here. So just to bring you up to speed with what the plan is, if we look at our robot builder, each one of these parts is going to be a different instance of the PartSelector, and the RobotBuilder will be responsible for giving each instance of the PartSelector the correct list of parts for it to work with. So in the RobotBuilder, when we create this instance of the PartSelector, it will pass in a list of heads, and when it creates this one, it will pass in a list of arms, etc. This will be a great way to learn how to communicate with child components. And now that the PartSelector will be taking care of all of the selecting of the parts, then over in our RobotBuilder we can delete a bunch of stuff here. So we can delete these functions here that we saw exist now over in the PartSelector, and then we can delete all of these functions down here. And notice how many of these there are that we're going to be deleting, and all of these will be replaced with just two functions in the PartSelector. So you can see how this is going to be eliminating duplication, and it's going to be a lot cleaner. All right, and then we're not going to needs these selected indexes here, either. And then we're just going to initialize each one of these parts in our selected robot to just an empty object, so each one of these will be just initialized like this. And actually, now that this doesn't have any complex calculations anymore, it doesn't really need to be a computed property, so let's just move this up to our data object. And this will just be a property instead of a function, and it'll just return this object. And now we're just going to go ahead and import our PartSelector. All right, and then this is something that you may not have noticed in the App component, but whenever you reference a child component, not only do you need to import it; you also need to list it in a components array on the parent component like this. This is what makes our component aware of this selector so that we can now use it up here. Okay, so now we're going to replace each one of these with just a PartSelector. So we have one at the bottom for our base, three in the middle for the left arm, torso, and right arm, and then up here in the head, we have a little bit more going on. So we can go ahead and replace all of this here with the PartSelector, and we can get rid of this div here. This stuff, however, we're going to want to reuse later, and so I'm just going to comment that out for now. Okay, so now we can use these PartSelector elements because we have declared them down here. Oh, and actually, this is not supposed to be an array; this is an object. So this is really an object where we're saying that we have a PartSelector component that is set to that PartSelector, but we can just use the shorthand syntax like this. But you can see already how much cleaner our template is because we cleaned up so much duplication. So let's go check this out. Okay, well, we've got all heads again, so not exactly what we want, but it is what we expected since our PartSelector is currently just hardcoded to return heads. To fix that, each instance of our PartSelector needs to receive its list of parts from its parent component, so we'll do that next. But you'll also notice that our arrows on our buttons are missing, and the buttons aren't exactly in the right place. So depending on where the PartSelector is, sometimes the buttons need to be on the top and bottom of the image, and sometimes they need to be on the left and right. So the PartSelector will also need to know what position it's in before it knows what type of buttons to display, so we'll fix that too. We'll get into all of that in the next clip when we start talking about how to pass data down to child components.
￼

--> 4.3 - Using Props to Share Data with Child Components
          We need to update our RobotBuilder to pass in the parts to the PartSelector for it to cycle through. So we'll start with this first one, which should allow the user to select which robot head they want. So that means over in our RobotBuilder, right here we want to tell the PartSelector which parts to use, and we'd like to do that like this. So availableParts is already available to us in our RobotBuilder's data object, and then we're just grabbing the heads off of it. And notice that we're binding it to a parts attribute of the PartSelector. This won't work yet because the PartSelector doesn't have a parts attribute to bind to. We'll add that next. We can do that over in the PartSelector by just adding props to the component like this. And then the most simple syntax for this is just to pass in a string array. And that's all there is to making props available to be bound to by parent components. And now that we have that, we can stop hardcoding the parts up here, which means we don't need this import here.

          And then down here inside the component wherever we're using parts, this needs to be this.parts now, since we're getting that off the props. Okay, so now that we have that prop, let's go ahead and pass in the correct parts in each of these instances. I'll just copy and paste this. And this is torsos, and this is arms again, and then this one is bases. Cool, let's go see how this looks. Awesome, now we're getting the correct parts, even though the arms aren't quite positioned right. And even though our buttons are still missing their arrow icons and aren't quite positioned right, if I click them, they do work. And you can see our PartSelector even supports indicting if a part is on sale. Now in order to fix the arm positions and display the buttons correctly, we need to apply a CSS class to each one of these PartSelectors based on the position of each part selector. So for example, this part selector for the head is in the top position. This left arm selector is in the left position, this one's in the center position, this one's in the right position, and this one's in the bottom position. And if we take a look at the PartSelector down in the styles, you can see that I've already created CSS classes to handle displaying those correctly. But these position classes aren't being applied yet anywhere in our PartSelector component, and that's partly because the PartSelector component doesn't know what position it's in. So let's come back over to the RobotBuilder, and in addition to specifying the parts for each one, let's specify the position. So I'm going to set position=top. And notice there's something different about this binding. Notice the parts binding is using a colon, but the position is not. That's because position isn't really actually a binding. It's really just an attribute on the PartSelector, and we're setting it to the hardcoded string top. Whereas parts is an attribute, but we're binding to that attribute and passing along availableParts.heads, which is an expression that needs to be evaluated. So let's go ahead and add this position to each of these others too. So we've got left and center, and then this is going to be right, and then finally down here for our base, this is going to be bottom. Okay, now we're passing to our PartSelector what position it's in, so over here we need to add a position prop so it can receive that value. And now we're just going to use that in a class binding. So up here in the template, right here on this div, in addition to the part class, I also want to bind to the position. So remember, we can specify both a class and class binding, and they'll get combined. And so in the case of the head, this div will have two classes, a part class and a top class. So whatever value is passed in to the PartSelector for the position prop will become a class here. And then based on those classes and the styles that we specified below, everything will get styled correctly. So let's go take a look at our component again. There we go. Now our buttons are all positioned and you can see that some are on top and some are on bottom versus left and right, and the arrows are all there. And that all came from our CSS styling. So just to review the important parts of this, we can pass data into child components using attributes like this, and for each attribute, you just need to specify props in the child component. It's really that simple to pass data to a child component. We can, however, take this a little bit further and actually validate the props that are passed to make sure that they're the right type, etc. Let's take a look at that next.

          Validating Props
          Our PartSelector component now takes in two props, parts and position, but there are no restrictions on the type of data or values that could be passed in to these props. We'd like to provide some validation to prevent parent components from passing in bad data. That's actually quite easy to do with a little different syntax. Let's start by requiring the parts prop to be an array and the position prop to be a string. So instead of using an array here, we'll use a keyed object where the keys are the names of the props, and the values are objects that specify validation information. So for the parts prop, we expect its type to be an array, and for position we expect its type to be a string. And now that we have these in place, if we come back over to our RobotBuilder, and on one of these, instead of passing in an array for the parts, we'll just pass in a string. And now if we come back over here, obviously, our left arm selector isn't going to be working because it's a string, not an array of parts. But if we take a look in our browser, you can see that we have a validation message here because we passed in an invalid data type for the parts. And you can see right here it says Expected Array but got String. So we now have type checking that can help us identify problems during development. So let's go back and fix that. And then we can also make our props required. So here I'm going to, in addition in to specifying type, specify required: true, and then we'll do that for position, too, because it's also required. And now over here in our RobotBuilder, let's not pass in the left position. So if we come back over here, let's clear this and refresh. Well, you might be surprised to see here that there is no message. There's no validation error, and that's because, if we look at what we passed in, we didn't pass in nothing. We actually passed in an empty string. And so because we are providing a value for a position, it's not triggering the validation message. If we remove this altogether, however, and come back over here, there, now you can see it's saying that there is a required prop that's missing. But what if we actually do want to ensure that users cannot pass in an empty string here? Essentially, we want to indicate what are the valid values for position? So we can do that with a validator function. So in addition to specifying that position is required, we're going to supply a validator function, and that is a function that takes in the value that's being passed in to the prop. And we just want to ensure that it is one of these values, left, right, top, bottom, or center. So basically, I just want to make sure that the value is included in that array, or that this array includes the values that's passed in. Okay, now because we are passing in an empty string, we should now be seeing an error over here, and sure enough, if we refresh here, you can see that we are getting an error that the custom validator failed for prop position. Cool, so let's go back to our RobotBuilder and pass position back in here, and then if I clear this and refresh, you can see we're not getting that error anymore. And our RobotBuilder looks great. So awesome, we're now validating the props that being passed into our child component. Next, we'll take a look at how to pass data back to a parent component from a child component.


Parent

# Here, we're binding it to a parts attribute of the PartSelector.
<PartSelector :parts="availableParts.heads" />


# Child
# Child should use the props in the component like this:

export default {
    props: ['parts'],
    data() {
      return { selectedPartIndex: 0 };
    },
    ...
}


:parts is an attribute which is binded.
position is a no binding attribute.

<PartSelector
  :parts="availableParts.heads",
  position="top"
/>
￼
# In summary, to pass data to the child component, it is needed to add to the component tag the attributes that you want to use
# inside the component child. Furthemore, in the child component you need to add a 'props' attribute to the component, which is an array
# that store strings of variables passed by its parents.
￼

￼

￼

￼


